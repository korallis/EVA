import { app, BrowserWindow, shell, ipcMain } from 'electron';
import { URL } from 'url';
import fetch from 'node-fetch';
import Store from 'electron-store';
import { ESI_CONFIG } from './shared/constants';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

interface TokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
}

interface CharacterInfo {
  character_id: number;
  character_name: string;
  expires_on: string;
  scopes: string;
  token_type: string;
}

class EVAApp {
  private mainWindow: BrowserWindow | null = null;
  private store: Store;
  private authResolve: ((value: boolean) => void) | null = null;
  private authReject: ((reason?: any) => void) | null = null;
  private currentState: string | null = null;

  constructor() {
    this.store = new Store({
      encryptionKey: 'eva-encryption-key',
      name: 'eva-auth-data'
    }) as any; // Type assertion to fix electron-store v10+ API
    this.setupApp();
  }

  private setupApp(): void {
    // Setup URL scheme handling like EVE Online
    app.setAsDefaultProtocolClient('eva');
    app.setAsDefaultProtocolClient('evaapp');

    // Handle URL scheme events
    app.on('open-url', (event, url) => {
      event.preventDefault();
      this.handleAuthCallback(url);
    });

    // For Windows - handle protocol in second instance
    app.on('second-instance', (event, commandLine) => {
      const url = commandLine.find(arg => arg.startsWith('eva://') || arg.startsWith('evaapp://'));
      if (url) {
        this.handleAuthCallback(url);
      }
      
      // Focus the main window
      if (this.mainWindow) {
        if (this.mainWindow.isMinimized()) this.mainWindow.restore();
        this.mainWindow.focus();
      }
    });

    // This method will be called when Electron has finished initialization
    app.on('ready', () => {
      this.createMainWindow();
      this.setupIPC();
    });

    // Quit when all windows are closed, except on macOS
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });

    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        this.createMainWindow();
      }
    });
  }

  private createMainWindow(): void {
    this.mainWindow = new BrowserWindow({
      height: 800,
      width: 1200,
      minHeight: 600,
      minWidth: 800,
      show: false,
      autoHideMenuBar: true,
      titleBarStyle: process.platform === 'darwin' ? 'hiddenInset' : 'default',
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        webSecurity: true
      },
    });

    this.mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Show window when ready
    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow?.show();
      
      if (process.env.NODE_ENV === 'development') {
        this.mainWindow?.webContents.openDevTools();
      }
    });

    this.mainWindow.on('closed', () => {
      this.mainWindow = null;
    });
  }

  private setupIPC(): void {
    // Authentication IPC handlers
    ipcMain.handle('auth:start', async () => {
      return this.startAuthentication();
    });

    ipcMain.handle('auth:check', async () => {
      return this.isTokenValid();
    });

    ipcMain.handle('auth:getCharacter', async () => {
      return this.getStoredCharacterInfo();
    });

    ipcMain.handle('auth:logout', async () => {
      return this.logout();
    });

    // ESI API handlers
    ipcMain.handle('esi:getCharacterSkills', async (event, characterId: string) => {
      return this.getCharacterSkills(characterId);
    });

    ipcMain.handle('esi:getCharacterSkillQueue', async (event, characterId: string) => {
      return this.getCharacterSkillQueue(characterId);
    });

    ipcMain.handle('esi:getSkillInfo', async (event, skillIds: number[]) => {
      return this.getSkillInfo(skillIds);
    });
  }

  // Authentication methods
  private async startAuthentication(): Promise<boolean> {
    return new Promise((resolve, reject) => {
      try {
        this.authResolve = resolve;
        this.authReject = reject;

        const authUrl = this.generateAuthUrl();
        
        // Open authentication URL in system browser (like EVE Online)
        shell.openExternal(authUrl);
        
        console.log('üöÄ Authentication started - opening browser...');
        console.log('Auth URL:', authUrl);
        
        // Set timeout for authentication
        setTimeout(() => {
          if (this.authReject) {
            this.authReject(new Error('Authentication timeout - user did not complete login within 5 minutes'));
            this.cleanupAuthHandlers();
          }
        }, 5 * 60 * 1000); // 5 minute timeout

      } catch (error) {
        console.error('Failed to start authentication:', error);
        reject(new Error(`Authentication failed: ${error}`));
      }
    });
  }

  private generateAuthUrl(): string {
    const state = this.generateRandomState();
    this.currentState = state;

    const params = new URLSearchParams({
      response_type: 'code',
      redirect_uri: ESI_CONFIG.CALLBACK_URL,
      client_id: ESI_CONFIG.CLIENT_ID,
      scope: ESI_CONFIG.SCOPES.join(' '),
      state: state
    });

    return `${ESI_CONFIG.LOGIN_URL}?${params.toString()}`;
  }

  private generateRandomState(): string {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
  }

  private async handleAuthCallback(url: string): Promise<void> {
    try {
      console.log('üìû Received auth callback:', url);
      
      const parsedUrl = new URL(url);
      
      // Only handle our auth callbacks
      if (!url.startsWith('eva://auth/callback') && !url.startsWith('evaapp://auth/callback')) {
        console.log('Ignoring non-auth callback URL');
        return;
      }

      const code = parsedUrl.searchParams.get('code');
      const state = parsedUrl.searchParams.get('state');
      const error = parsedUrl.searchParams.get('error');

      if (error) {
        console.error('‚ùå OAuth error in callback:', error);
        if (this.authReject) {
          this.authReject(new Error(`OAuth error: ${error}`));
          this.cleanupAuthHandlers();
        }
        return;
      }

      if (!code || !state) {
        console.error('‚ùå Missing code or state in callback');
        if (this.authReject) {
          this.authReject(new Error('Missing authorization code or state parameter'));
          this.cleanupAuthHandlers();
        }
        return;
      }

      // Verify state parameter
      if (state !== this.currentState) {
        console.error('‚ùå State mismatch in callback');
        if (this.authReject) {
          this.authReject(new Error('Invalid state parameter - possible security issue'));
          this.cleanupAuthHandlers();
        }
        return;
      }

      console.log('‚úÖ Valid auth callback received, processing...');
      
      // Process the authorization code
      await this.processAuthorizationCode(code);
      
      console.log('üéâ Authentication completed successfully');
      
      // Notify renderer of successful authentication
      if (this.mainWindow) {
        this.mainWindow.webContents.send('auth:success');
      }
      
      if (this.authResolve) {
        this.authResolve(true);
        this.cleanupAuthHandlers();
      }

    } catch (error) {
      console.error('‚ùå Error handling auth callback:', error);
      if (this.authReject) {
        this.authReject(error);
        this.cleanupAuthHandlers();
      }
    }
  }

  private cleanupAuthHandlers(): void {
    this.authResolve = null;
    this.authReject = null;
    this.currentState = null;
  }

  private async processAuthorizationCode(code: string): Promise<void> {
    try {
      console.log('üîÑ Exchanging authorization code for tokens...');
      const tokenData = await this.exchangeCodeForToken(code);
      
      // Store tokens securely
      (this.store as any).set('access_token', tokenData.access_token);
      if (tokenData.refresh_token) {
        (this.store as any).set('refresh_token', tokenData.refresh_token);
      }
      
      // Calculate and store expiry time
      const expiryTime = Date.now() + (tokenData.expires_in * 1000);
      (this.store as any).set('token_expiry', expiryTime);
      
      // Get character information
      console.log('üë§ Getting character information...');
      const characterInfo = await this.getCharacterInfoFromToken(tokenData.access_token);
      (this.store as any).set('character_info', characterInfo);
      
      console.log('üíæ Authentication tokens stored successfully');
      console.log('Character:', characterInfo.character_name);
    } catch (error) {
      console.error('Failed to process authorization code:', error);
      throw error;
    }
  }

  private async exchangeCodeForToken(code: string): Promise<TokenResponse> {
    const params = new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      client_id: ESI_CONFIG.CLIENT_ID,
      client_secret: ESI_CONFIG.CLIENT_SECRET,
      redirect_uri: ESI_CONFIG.CALLBACK_URL
    });

    const response = await fetch(ESI_CONFIG.TOKEN_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': ESI_CONFIG.USER_AGENT
      },
      body: params.toString()
    } as any);

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Token exchange failed: ${response.status} ${errorText}`);
    }

    return await response.json() as TokenResponse;
  }

  private async getCharacterInfoFromToken(accessToken: string): Promise<CharacterInfo> {
    const response = await fetch('https://login.eveonline.com/oauth/verify', {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'User-Agent': ESI_CONFIG.USER_AGENT
      }
    } as any);

    if (!response.ok) {
      throw new Error(`Failed to get character info: ${response.status}`);
    }

    return await response.json() as CharacterInfo;
  }

  private async isTokenValid(): Promise<boolean> {
    try {
      const accessToken = (this.store as any).get('access_token');
      const expiry = (this.store as any).get('token_expiry') as number;
      
      if (!accessToken || !expiry) {
        return false;
      }

      const now = Date.now();
      
      // Token is valid if it doesn't expire within the next 5 minutes
      return expiry > (now + 5 * 60 * 1000);
    } catch (error) {
      console.error('Error checking token validity:', error);
      return false;
    }
  }

  private getStoredCharacterInfo(): CharacterInfo | null {
    try {
      return (this.store as any).get('character_info') as CharacterInfo || null;
    } catch (error) {
      console.error('Error getting character info:', error);
      return null;
    }
  }

  private async logout(): Promise<void> {
    try {
      (this.store as any).delete('access_token');
      (this.store as any).delete('refresh_token');
      (this.store as any).delete('token_expiry');
      (this.store as any).delete('character_info');
      
      this.cleanupAuthHandlers();
      
      console.log('Logout completed');
    } catch (error) {
      console.error('Error during logout:', error);
      throw error;
    }
  }

  // ESI API methods
  private async getCharacterSkills(characterId: string): Promise<any> {
    const accessToken = (this.store as any).get('access_token') as string;
    if (!accessToken) {
      throw new Error('No access token available');
    }

    const response = await fetch(
      `${ESI_CONFIG.ESI_BASE_URL}/latest/characters/${characterId}/skills/`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'User-Agent': ESI_CONFIG.USER_AGENT
        }
      } as any
    );

    if (!response.ok) {
      throw new Error(`Failed to get character skills: ${response.status}`);
    }

    return await response.json();
  }

  private async getCharacterSkillQueue(characterId: string): Promise<any> {
    const accessToken = (this.store as any).get('access_token') as string;
    if (!accessToken) {
      throw new Error('No access token available');
    }

    const response = await fetch(
      `${ESI_CONFIG.ESI_BASE_URL}/latest/characters/${characterId}/skillqueue/`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'User-Agent': ESI_CONFIG.USER_AGENT
        }
      } as any
    );

    if (!response.ok) {
      throw new Error(`Failed to get character skill queue: ${response.status}`);
    }

    return await response.json();
  }

  private async getSkillInfo(skillIds: number[]): Promise<Record<number, any>> {
    const skillInfo: Record<number, any> = {};
    
    // Batch requests to avoid rate limiting
    for (const skillId of skillIds) {
      try {
        const response = await fetch(
          `${ESI_CONFIG.ESI_BASE_URL}/latest/universe/types/${skillId}/`,
          {
            headers: {
              'User-Agent': ESI_CONFIG.USER_AGENT
            }
          } as any
        );

        if (response.ok) {
          skillInfo[skillId] = await response.json();
        }
      } catch (error) {
        console.error(`Failed to get skill info for ${skillId}:`, error);
      }
    }

    return skillInfo;
  }
}

// Initialize the application
new EVAApp();